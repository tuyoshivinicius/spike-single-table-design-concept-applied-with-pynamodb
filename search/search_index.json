{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Spike Single Table Design com PynamoDB","text":""},{"location":"#visao-geral","title":"Vis\u00e3o Geral","text":"<p>Este projeto \u00e9 uma spike t\u00e9cnica com fins did\u00e1ticos. Seu objetivo \u00e9 explorar, de maneira pr\u00e1tica e clara, a implementa\u00e7\u00e3o de uma tabela no AWS DynamoDB usando o padr\u00e3o Single Table Design (STD) atrav\u00e9s da biblioteca PynamoDB em Python.</p> <p>O projeto visa auxiliar desenvolvedores na compreens\u00e3o e implementa\u00e7\u00e3o desse padr\u00e3o, mostrando como utilizar modelos claros e organizados com a PynamoDB.</p> <p>\ud83d\udcc3 SITE DOCUMENTA\u00c7\u00c3O</p>"},{"location":"#o-que-e-single-table-design","title":"O que \u00e9 Single Table Design?","text":"<p>O Single Table Design \u00e9 um padr\u00e3o recomendado pela AWS para estruturar tabelas no DynamoDB, utilizando apenas uma tabela para armazenar diferentes tipos de entidades relacionadas. Ao inv\u00e9s de utilizar m\u00faltiplas tabelas, os dados s\u00e3o agrupados numa \u00fanica tabela, diferenciando as entidades atrav\u00e9s de chaves de parti\u00e7\u00e3o (<code>Partition Key</code>) e chaves de ordena\u00e7\u00e3o (<code>Sort Key</code>).</p>"},{"location":"#beneficios-do-single-table-design","title":"Benef\u00edcios do Single Table Design:","text":"<ul> <li>Redu\u00e7\u00e3o de custos operacionais.</li> <li>Melhor performance nas consultas.</li> <li>Facilita a escalabilidade.</li> </ul> <p>Exemplo simplificado:</p> PK SK Dados USER#123 PROFILE { \"nome\": \"Jo\u00e3o\", \"email\": \"joao@example.com\" } USER#123 ORDER#987 { \"total\": 50.00 }"},{"location":"#por-que-usar-pynamodb","title":"Por que usar PynamoDB?","text":"<p>PynamoDB \u00e9 uma biblioteca Python que oferece uma interface f\u00e1cil e intuitiva para interagir com o DynamoDB, similar a um ORM (Object-Relational Mapper). Ela abstrai detalhes complexos do gerenciamento de tabelas e entidades, facilitando o desenvolvimento de aplica\u00e7\u00f5es claras e robustas.</p> <p>Principais vantagens:</p> <ul> <li>Simplicidade na defini\u00e7\u00e3o de modelos.</li> <li>Abstra\u00e7\u00e3o da complexidade dos tipos e \u00edndices DynamoDB.</li> <li>Facilidade na escrita e leitura de consultas complexas.</li> </ul>"},{"location":"#estrutura-da-tabela","title":"Estrutura da Tabela","text":"<p>A tabela utilizada neste projeto segue o padr\u00e3o STD com os seguintes elementos principais:</p> <ul> <li><code>PK</code> (Partition Key): Identifica a entidade principal (ex: USER#id).</li> <li><code>SK</code> (Sort Key): Diferencia dados adicionais associados \u00e0 entidade (ex: ORDER#id, PROFILE).</li> <li>Atributo <code>data</code>: Armazena detalhes espec\u00edficos em formato estruturado.</li> </ul>"},{"location":"#exemplos-de-modelagem","title":"Exemplos de Modelagem:","text":""},{"location":"#basemodel","title":"BaseModel","text":"<pre><code>class BaseModel(Model):\n    class Meta:\n        table_name = \"AppData\"\n        region = \"us-east-1\"\n\n    PK = UnicodeAttribute(hash_key=True)\n    SK = UnicodeAttribute(range_key=True)\n</code></pre>"},{"location":"#usermodel","title":"UserModel","text":"<pre><code>class UserDataMap(MapAttribute):\n    name = UnicodeAttribute(null=True)\n    email = UnicodeAttribute(null=True)\n\nclass UserModel(BaseModel):\n    data = UserDataMap()\n\n    @classmethod\n    def build_pk(cls, user_id):\n        return f\"USER#{user_id}\"\n\n    @classmethod\n    def build_sk(cls):\n        return \"PROFILE\"\n</code></pre>"},{"location":"#ordermodel","title":"OrderModel","text":"<pre><code>class OrderDataMap(MapAttribute):\n    total = NumberAttribute(null=True)\n\nclass OrderModel(BaseModel):\n    data = OrderDataMap()\n\n    @classmethod\n    def build_pk(cls, user_id):\n        return f\"USER#{user_id}\"\n\n    @classmethod\n    def build_sk(cls, order_id):\n        return f\"ORDER#{order_id}\"\n</code></pre>"},{"location":"#exemplos-de-codigo","title":"Exemplos de C\u00f3digo","text":"<p>O projeto inclui exemplos claros e comentados:</p> <ul> <li>Cria\u00e7\u00e3o e consulta de usu\u00e1rios.</li> <li>Inser\u00e7\u00e3o e consulta de pedidos.</li> </ul> <p>Exemplo did\u00e1tico de inser\u00e7\u00e3o:</p> <pre><code>UserModel(\n    PK=UserModel.build_pk(\"001\"),              \n    SK=UserModel.build_sk(),                   \n    data=UserDataMap(name=\"Ana\", email=\"ana@example.com\") \n).save()\n\n\nOrderModel(\n    PK=OrderModel.build_pk(\"001\"), \n    SK=OrderModel.build_sk(\"A1001\"),\n    data=OrderDataMap(total=99.99) \n).save()\n</code></pre> <p>Consulta usando PynamoDB:</p> <p><pre><code>user_iterator = UserModel.query(\n    hash_key=UserModel.build_pk(user_id),\n    range_key_condition=UserModel.SK == UserModel.build_sk()\n)\n\norder_iterator = OrderModel.query(\n    hash_key=OrderModel.build_pk(user_id),\n    range_key_condition=OrderModel.SK.startswith(\"ORDER#\")  # Filtra pedidos via prefixo\n)\n</code></pre> Esses exemplos ajudam a visualizar claramente o funcionamento do padr\u00e3o STD com PynamoDB.</p>"},{"location":"#estrutura-de-arquivos","title":"Estrutura de Arquivos","text":""},{"location":"#runpy-script-principal-de-execucao-requirementstxt-dependencias-do-projeto-src-apppy-logica-principal-execucao-e-simulacao-models-base_modelpy-modelo-base-compartilhado-user_modelpy-modelo-de-usuario-order_modelpy-modelo-de-pedido","title":"<pre><code>\u251c\u2500\u2500 run.py                     // Script principal de execu\u00e7\u00e3o\n\u251c\u2500\u2500 requirements.txt           // Depend\u00eancias do projeto\n\u2514\u2500\u2500 src/\n    \u251c\u2500\u2500 app.py                 // L\u00f3gica principal (execu\u00e7\u00e3o e simula\u00e7\u00e3o)\n    \u2514\u2500\u2500 models/\n        \u251c\u2500\u2500 base_model.py      // Modelo base compartilhado\n        \u251c\u2500\u2500 user_model.py      // Modelo de usu\u00e1rio\n        \u2514\u2500\u2500 order_model.py     // Modelo de pedido\n</code></pre>","text":""},{"location":"#como-executar-o-projeto-localmente","title":"Como Executar o Projeto Localmente","text":""},{"location":"#pre-requisitos","title":"Pr\u00e9-requisitos","text":"<ul> <li>Python 3.11+</li> </ul>"},{"location":"#dependencias","title":"Depend\u00eancias","text":"<p>Instale as depend\u00eancias usando:</p> <pre><code>pip install -r requirements.txt\n</code></pre>"},{"location":"#execucao","title":"Execu\u00e7\u00e3o","text":"<p>Rode o projeto:</p> <pre><code>python run.py\n</code></pre>"},{"location":"#saida-esperada","title":"Sa\u00edda Esperada","text":"<p>Ao executar o script <code>run.py</code>, voc\u00ea ver\u00e1 a seguinte sa\u00edda (simulada via <code>moto</code>, sem conex\u00e3o real com a AWS):</p> <pre><code>{\n  \"user_id\": \"001\",\n  \"name\": \"Ana\",\n  \"email\": \"ana@example.com\",\n  \"orders\": [\n    {\n      \"order_id\": \"A1001\",\n      \"total\": 99.99\n    },\n    {\n      \"order_id\": \"A1002\",\n      \"total\": 102.2\n    }\n  ]\n}\n</code></pre> <p>Essa sa\u00edda demonstra o funcionamento completo do padr\u00e3o Single Table Design, mostrando como diferentes tipos de itens (usu\u00e1rios e pedidos) podem coexistir e ser consultados eficientemente em uma \u00fanica tabela do DynamoDB.</p>"},{"location":"#pontos-de-atencao-e-boas-praticas","title":"Pontos de Aten\u00e7\u00e3o e Boas Pr\u00e1ticas","text":"<ul> <li>Padroniza\u00e7\u00e3o das chaves: Utilize nomenclaturas consistentes e claras para <code>Partition Key</code> e <code>Sort Key</code>.</li> <li>Modelos estruturados: Utilize modelos base para abstrair configura\u00e7\u00f5es comuns e simplificar manuten\u00e7\u00e3o.</li> <li>Valida\u00e7\u00e3o de atributos: Sempre valide atributos obrigat\u00f3rios e opcionais explicitamente nos seus modelos.</li> <li>Performance nas consultas: Evite consultas que possam gerar varreduras completas da tabela (table scans).</li> <li>Gerenciamento de depend\u00eancias: Sempre mantenha as vers\u00f5es das bibliotecas (como <code>boto3</code>, <code>pynamodb</code>) atualizadas.</li> <li>Testes e simula\u00e7\u00f5es: Utilize ferramentas como o Moto para simular o DynamoDB localmente antes do deploy na AWS.</li> </ul>"},{"location":"#recursos-adicionais","title":"Recursos Adicionais","text":"<ul> <li>AWS DynamoDB Best Practices</li> <li>Documenta\u00e7\u00e3o oficial PynamoDB</li> <li>Single Table Design - Alex DeBrie</li> </ul>"}]}